---
phase: 04-push
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/netbox_auto/netbox.py]
autonomous: true

must_haves:
  truths:
    - "NetBoxClient can create a device in NetBox"
    - "NetBoxClient can create a VM in NetBox"
    - "NetBoxClient can create a cable between switch port and device"
    - "NetBoxClient can assign IP address to device interface"
  artifacts:
    - path: "src/netbox_auto/netbox.py"
      provides: "NetBox API push methods"
      exports: ["create_device", "create_vm", "create_cable", "assign_ip"]
  key_links:
    - from: "create_device"
      to: "pynetbox.dcim.devices.create"
      via: "API call"
    - from: "create_cable"
      to: "pynetbox.dcim.cables.create"
      via: "API call with interface endpoints"
---

<objective>
Extend NetBoxClient with methods to create devices, VMs, cables, and IP assignments.

Purpose: Foundation for push command - all NetBox write operations in one module.
Output: NetBoxClient with create_device(), create_vm(), create_cable(), assign_ip() methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-review/03-03-SUMMARY.md

@src/netbox_auto/netbox.py
@src/netbox_auto/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add device and VM creation methods</name>
  <files>src/netbox_auto/netbox.py</files>
  <action>
Add to NetBoxClient:
- create_device(name, device_type_id, device_role_id, site_id) -> dict with id
- create_vm(name, cluster_id) -> dict with id
- assign_ip(ip_address, interface_id) -> dict with id

For create_device: use api.dcim.devices.create()
For create_vm: use api.virtualization.virtual_machines.create() with status="active"
For assign_ip: use api.ipam.ip_addresses.create() with assigned_object_type/id

Return dict with created object id on success, raise on failure (push should fail loudly).
  </action>
  <verify>python -c "from netbox_auto.netbox import NetBoxClient; c = NetBoxClient(); print(hasattr(c, 'create_device'), hasattr(c, 'create_vm'), hasattr(c, 'assign_ip'))"</verify>
  <done>create_device, create_vm, assign_ip methods exist and use pynetbox API</done>
</task>

<task type="auto">
  <name>Task 2: Add cable creation method</name>
  <files>src/netbox_auto/netbox.py</files>
  <action>
Add to NetBoxClient:
- create_cable(a_termination_type, a_termination_id, b_termination_type, b_termination_id) -> dict with id

Use api.dcim.cables.create() with:
- a_terminations: [{"object_type": a_termination_type, "object_id": a_termination_id}]
- b_terminations: [{"object_type": b_termination_type, "object_id": b_termination_id}]

Termination types are "dcim.interface" for device interfaces.
Also add helper: get_or_create_interface(device_id, name) that finds or creates interface on device.
  </action>
  <verify>python -c "from netbox_auto.netbox import NetBoxClient; c = NetBoxClient(); print(hasattr(c, 'create_cable'), hasattr(c, 'get_or_create_interface'))"</verify>
  <done>create_cable and get_or_create_interface methods exist</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All methods added to NetBoxClient
- [ ] Methods use correct pynetbox API endpoints
- [ ] python -m py_compile src/netbox_auto/netbox.py succeeds
- [ ] make lint passes (ruff + mypy)
</verification>

<success_criteria>
- All tasks completed
- NetBoxClient has create_device, create_vm, create_cable, assign_ip, get_or_create_interface
- Methods follow existing error handling patterns (log and raise on failure)
</success_criteria>

<output>
After completion, create `.planning/phases/04-push/04-01-SUMMARY.md`
</output>

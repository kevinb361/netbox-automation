"""DNS push module for Unbound servers.

Provides functions to generate Unbound local-data configuration and
push it to Unbound servers via SSH.
"""

import logging
from datetime import datetime

import paramiko

from netbox_auto.config import get_config
from netbox_auto.models import Host

logger = logging.getLogger(__name__)


def generate_unbound_config(hosts: list[Host], domain: str = "lan") -> str:
    """Generate Unbound local-data configuration from hosts.

    Args:
        hosts: List of Host objects to generate DNS records for.
        domain: Domain suffix for hostnames (default: "lan").

    Returns:
        Unbound local-data configuration as a string.
    """
    lines = [
        f"# Unbound local-data configuration",
        f"# Generated by netbox-auto at {datetime.utcnow().isoformat()}Z",
        f"# Total hosts: {len(hosts)}",
        "",
    ]

    for host in hosts:
        if not host.hostname:
            logger.debug(f"Skipping host {host.mac} - no hostname")
            continue

        hostname = host.hostname
        # Add domain suffix if hostname doesn't already have one
        if "." not in hostname:
            fqdn = f"{hostname}.{domain}"
        else:
            fqdn = hostname

        # Handle multiple IPs per host
        ip_addresses = host.ip_addresses if isinstance(host.ip_addresses, list) else []
        if not ip_addresses:
            logger.debug(f"Skipping host {hostname} - no IP addresses")
            continue

        for ip in ip_addresses:
            # Strip any prefix length (e.g., "192.168.1.1/24" -> "192.168.1.1")
            ip_clean = ip.split("/")[0] if "/" in ip else ip
            lines.append(f'local-data: "{fqdn}. A {ip_clean}"')

    lines.append("")  # Trailing newline
    return "\n".join(lines)


def push_dns_config(config: str, dry_run: bool = False) -> list[str]:
    """Push Unbound configuration to all configured servers via SSH.

    Args:
        config: Unbound local-data configuration string.
        dry_run: If True, only log what would happen without connecting.

    Returns:
        List of hostnames that were successfully updated.

    Raises:
        Exception: If SSH connection or command execution fails.
    """
    app_config = get_config()
    unbound_config = app_config.unbound
    updated_hosts: list[str] = []

    if not unbound_config.hosts:
        logger.warning("No Unbound hosts configured - skipping DNS push")
        return updated_hosts

    for host_config in unbound_config.hosts:
        host = host_config.host
        user = host_config.user
        config_path = host_config.config_path

        if dry_run:
            logger.info(f"[DRY RUN] Would connect to {user}@{host}")
            logger.info(f"[DRY RUN] Would write config to {config_path}")
            logger.info(f"[DRY RUN] Would run: sudo unbound-control reload")
            updated_hosts.append(host)
            continue

        logger.info(f"Connecting to {user}@{host}...")

        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            # Connect using key-based authentication (agent or default key)
            client.connect(hostname=host, username=user)
            logger.info(f"Connected to {host}")

            # Write config file via SFTP
            sftp = client.open_sftp()
            try:
                logger.info(f"Writing config to {config_path}")
                with sftp.file(config_path, "w") as f:
                    f.write(config)
            finally:
                sftp.close()

            # Reload Unbound
            logger.info("Reloading Unbound...")
            stdin, stdout, stderr = client.exec_command("sudo unbound-control reload")
            exit_status = stdout.channel.recv_exit_status()

            if exit_status != 0:
                error_output = stderr.read().decode().strip()
                raise RuntimeError(f"unbound-control reload failed: {error_output}")

            logger.info(f"Successfully updated DNS on {host}")
            updated_hosts.append(host)

        except Exception as e:
            logger.error(f"Failed to update DNS on {host}: {e}")
            raise

        finally:
            client.close()

    return updated_hosts
